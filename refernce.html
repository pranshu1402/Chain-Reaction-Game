HTMLResult
< !-- Chain Reaction is a game developed in HTML5 and Javascript. Copyright(C) 2014 Chain Reaction This program is free
    software; you can redistribute it and / or modify it under the terms of the GNU General Public License as published
    by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This
    program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the GNU General Public License for more details.
    You should have received a copy of the GNU General Public License along with this program; if not, write to the Free
    Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110 - 1301 USA. Author : Ganesh Prabu Ravi
    Email: ganeshprabhu1994@gmail.com GitHub: github.com / ganeshpraburavi -->
    < !DOCTYPE HTML>

        <head>
            <title>Chain Reaction</title>
            <style>
                a {
                    text - decoration: none;
                    color: rgb(30, 250, 30);
                }

                p {
                    color: rgb(30, 250, 30);
                }

                a:hover {
                    text - decoration: underline;
                }

                * {
                    margin: 0;
                    padding: 0;
                }

                body {
                    background - color: rgb(51, 51, 51);
                    color: rgb(30, 250, 30);
                    font-family: arial;
                }

                #container {
                    margin: 0px auto;
                    width: 1000px;
                    min-height: 400px;
                    padding: 10px;
                }

                #chainReaction {
                    cursor: pointer;
                    margin: 0px auto;
                    width: 400px;
                    height: 400px;
                    border: 1px solid rgba(250, 250, 250, 1);
                }

                header {
                    margin - bottom: 20px;
                }

                h1,
                footer {
                    font - family: raleway-light;
                    text-align: center;
                    color: rgb(30, 250, 30);
                }

                footer {
                    position: relative;
                    width: 100%;
                    bottom: 0px;
                }

                sub {
                    font - size: 12px;
                }

                #left {
                    float: left;
                    width: 200px;
                    border: 1px solid rgb(30, 250, 30);
                    border-bottom: none;
                    border-left: none;
                    border-top: none;
                    top: 100px;
                    color: rgb(30, 250, 30);
                    font-family: raleway;
                    text-align: center;
                    margin-top: 20%;
                    padding: 5px;
                }

                #left div {
                    padding: 5px;
                    margin-top: 5px;
                    border: 1px solid rgb(30, 250, 30);
                }

                #left div:hover {
                    color: black;
                    background-color: rgb(30, 250, 30);
                    cursor: pointer;
                }

                #ResultContainer {
                    width: 100%;
                    height: 100%;
                    margin: 0px auto;
                    position: absolute;
                    text-align: center;
                    background-color: rgba(0, 0, 0, 0.7);
                    z-index: 999;
                    display: none;
                }

                #Result {
                    border: 1px solid rgb(30, 250, 30);
                    padding: 20px 50px 20px 50px;
                    top: 44%;
                    left: 37%;
                    width: 200px;
                    height: 70px;
                    position: relative;
                }

                #ok {
                    background: none;
                    border: 1px solid rgb(30, 250, 30);
                    color: rgb(30, 250, 30);
                    padding: 5px;
                    bottom: 0px;
                    position: relative;
                }

                #ok:hover {
                    cursor: pointer;
                }
            </style>
        </head>

        <body>
            <div id="ResultContainer">
                <div id="Result">
                    <span id="winner">Ganesh Wins<br /></span>
                    <input type="button" id="ok" value="Great" />
                </div>
            </div>
            <!--<div id="left">
            <div id="newGame" onClick="init();">New Game</div>
            <div id="newGame">Undo</div>
        </div> -->
            <div id="container">
                <header>
                    <h1>Chain Reaction</h1>
                </header>

                <canvas id="chainReaction" width="400px" height="400px">
                </canvas>
            </div>
            <footer>
                <div>Ganesh Prabu Ravi</div>
                <div><a href="https://www.github.com/ganeshpraburavi">GitHub</a> . <a
                        href="https://www.facebook.com/ganeshpraburavi">Facebook</a> . <a
                        href="https://plus.google.com/+GaneshPrabuRavi">Google+</div>
            </footer>
            <script>
                //Canvas Context
                var ctx, c;
                var BOX_SIZE = 100; // Each Box Size
                var ROWS = 4; // Number of Rows and Cols.
                var COLS = 4;
                //Color Constants
                var numberOfPlayers = 2;
                var green = "rgba(0,255,0,1)";
                var red = "rgba(255,0,0,1)";
                var enableGameOver;
                var numberOfPlays;
                var condition;
                var travellingParticles = [];

                var currentPlayer = red; // Specifies the current players color

                //Box array which holds the properties of a box at any moment.
                var box;

                // identifes the position of the box, given the mouse points x and y
                function identifyBox(x, y) {
                    //console.log(x,y);
                    x = Math.ceil((x / ((BOX_SIZE * ROWS) + ROWS - 1)) * ROWS); // ROWS-1 is for borders
                    y = Math.ceil((y / ((BOX_SIZE * COLS) + COLS - 1)) * COLS); // COLS-1 is for borders
                    return { x: y, y: x };
                }

                // Burster - Main function
                function burst(color, x, y) {
                    if (box[x][y].capacity == 1)  // Corner Boxes
                        burstInto2(color, x, y);
                    else if (box[x][y].capacity == 2)  // Edge Boxes
                        burstInto3(color, x, y);
                    else if (box[x][y].capacity == 3) // Middle Boxes
                        burstInto4(color, x, y);
                }

                function isFull(x, y) {
                    if (box[x][y].atoms > box[x][y].capacity)
                        return true;
                    else
                        return false;
                }
                function burstIfFull(color, x, y) {
                    //update(currentPlayer);
                    if (box[x][y].atoms > box[x][y].capacity) {
                        box[x][y].particles = [];
                        burst(color, x, y);
                    }
                    return;
                }

                function addTravellingParticles(color, fromX, fromY, x, y) {
                    var dir, disp = 4, axis;
                    if (fromX == x) {
                        if (fromY > y) {
                            axis = 0;
                            disp = -4;
                        }
                        else
                            axis = 0;
                    }
                    else if (fromY == y) {
                        if (fromX > x) {
                            axis = 1;
                            disp = -4;
                        }
                        else
                            axis = 1;
                    }
                    travellingParticles.push({
                        curX: fromX * BOX_SIZE - 50,
                        curY: fromY * BOX_SIZE - 50,
                        toX: x,
                        toY: y,
                        axis: axis,
                        disp: disp,
                        color: color
                    });
                }

                function incrementAndBurst(color, fromx, fromy, x, y) {
                    //box[x][y].atoms++;
                    addTravellingParticles(color, fromx, fromy, x, y);
                    //box[x][y].color=currentPlayer;
                    //burstIfFull(x,y);
                }
                function incrementAndBurst2(color, x, y) {
                    box[x][y].atoms++;
                    pushAtom(x, y);
                    box[x][y].color = color;
                    burstIfFull(color, x, y);
                }
                //Utility Functions for burst

                function burstInto2(color, x, y)  // Corner Burster
                {
                    box[x][y].atoms = 0;
                    box[x][y].color = "none";
                    if (x == 1 && y == 1) {
                        incrementAndBurst(color, x, y, x + 1, y);
                        incrementAndBurst(color, x, y, x, y + 1);
                    }
                    if (x == ROWS && y == COLS) {
                        incrementAndBurst(color, x, y, ROWS - 1, COLS);
                        incrementAndBurst(color, x, y, ROWS, COLS - 1);
                    }
                    else if (x == 1 && y == COLS) {
                        incrementAndBurst(color, x, y, 1, COLS - 1);
                        incrementAndBurst(color, x, y, 2, COLS);
                    }
                    else if (x == ROWS && y == 1) {
                        incrementAndBurst(color, x, y, ROWS - 1, 1);
                        incrementAndBurst(color, x, y, ROWS, 2);
                    }
                }

                function burstInto4(color, x, y)  // Middle Burster
                {
                    box[x][y].atoms = 0;
                    box[x][y].color = "none";
                    incrementAndBurst(color, x, y, x + 1, y);
                    incrementAndBurst(color, x, y, x - 1, y);
                    incrementAndBurst(color, x, y, x, y - 1);
                    incrementAndBurst(color, x, y, x, y + 1);
                }

                function burstInto3(color, x, y) // Edge Burster
                {
                    box[x][y].atoms = 0;
                    box[x][y].color = "none";
                    if (x == ROWS) {
                        incrementAndBurst(color, x, y, x - 1, y);
                        incrementAndBurst(color, x, y, x, y - 1);
                        incrementAndBurst(color, x, y, x, y + 1);
                    }
                    else if (x == 1) {
                        incrementAndBurst(color, x, y, x + 1, y);
                        incrementAndBurst(color, x, y, x, y - 1);
                        incrementAndBurst(color, x, y, x, y + 1);
                    }
                    else if (y == 1) {
                        incrementAndBurst(color, x, y, x - 1, y);
                        incrementAndBurst(color, x, y, x + 1, y);
                        incrementAndBurst(color, x, y, x, y + 1);
                    }
                    else if (y == COLS) {
                        incrementAndBurst(color, x, y, x - 1, y);
                        incrementAndBurst(color, x, y, x + 1, y);
                        incrementAndBurst(color, x, y, x, y - 1);
                    }
                }

                function distance(x1, y1, x2, y2) {
                    var difx = Math.abs(x2 - x1);
                    var dify = Math.abs(y2 - y1);
                    return Math.sqrt(difx * difx + dify * dify);
                }
                function pushAtom(x, y) {
                    -
                    xy={ };
                    xy.x = x;
                    xy.y = y;
                    cx = xy.x * BOX_SIZE - 50;
                    cy = xy.y * BOX_SIZE - 50;
                    if (box[xy.x][xy.y].atoms == 1) {
                        gx = 27 + cx;
                        gy = 18 + cy;
                        ang = 0;
                    }
                    else if (box[xy.x][xy.y].atoms == 2) {
                        gx = 45 + cx;
                        gy = 28 + cy;
                        ang = 0;
                    }
                    else if (box[xy.x][xy.y].atoms == 3) {
                        gx = 40 + cx;
                        gy = 10 + cy;
                        ang = 30;
                    }
                    rad = distance(gx, gy, cx + 28, cy + 19);
                    //console.log(rad+" "+gx+" "+gy+" "+cx+" "+cy);
                    box[xy.x][xy.y].particles.push({
                        x: gx,
                        y: gy,
                        angle: ang,
                        radius: rad
                    });
                }

                //!IMPORTANT click event handler.
                function clickHandler(e) {
                    if (travellingParticles.length == 0) {
                        //console.log(e);
                        if (e.offsetY > BOX_SIZE * ROWS || e.offsetX > BOX_SIZE * COLS)
                            return;
                        xy = identifyBox(e.offsetX, e.offsetY); // box position
                        if (box[xy.x][xy.y].color != currentPlayer && box[xy.x][xy.y].color != "none")  // Handles if red player clicks on a green box
                        {
                            return;
                        }
                        else {
                            //console.log("I am in here;"+xy.x+" "+xy.y);
                            numberOfPlays++;
                            box[xy.x][xy.y].color = currentPlayer;
                            //console.log(xy.x*BOX_SIZE-50,xy.y*BOX_SIZE-50);
                            incrementAndBurst2(currentPlayer, xy.x, xy.y);
                            /*ctx.beginPath();
                            ctx.clearRect(xy.x*100-100,xy.y*100-100,xy.x*100,xy.y*100);
                            //ctx.arc(xy.x*100-50,xy.y*100-50,15,0,Math.PI*2); For Graphics
                            ctx.fillStyle=currentPlayer;
                            ctx.fillText(box[xy.x][xy.y].atoms,xy.x*100-50,xy.y*100-50);
                            ctx.fill();*/
                        }
                        if (currentPlayer == green)
                            currentPlayer = red;
                        else
                            currentPlayer = green;
                        update(currentPlayer);
                        //console.log(xy.x+" "+xy.y)
                    }
                }
                function boxInitialize() {
                    travellingParticles = [];
                    box = new Array(ROWS);
                    for (i = 0; i <= ROWS; i++) {
                        box[i] = new Array(COLS);
                    }
                    for (i = 1; i <= ROWS; i++) {
                        for (j = 1; j <= COLS; j++) {
                            box[i][j] = { "color": "none", "capacity": 3, "atoms": 0, "particles": [] };
                        }
                    }
                    for (i = 2; i <= COLS; i++) {
                        box[1][i].capacity = 2;
                        box[ROWS][i].capacity = 2;
                    }
                    for (i = 2; i <= ROWS; i++) {
                        box[i][1].capacity = 2;
                        box[i][COLS].capacity = 2;
                    }
                    box[1][1].capacity = 1;
                    box[1][COLS].capacity = 1;
                    box[ROWS][1].capacity = 1;
                    box[ROWS][COLS].capacity = 1;
                }
                function init() {
                    c = document.getElementById("chainReaction");
                    ctx = c.getContext("2d");
                    c.addEventListener("click", clickHandler);
                    enableGameOver = false;
                    condition = true;
                    numberOfPlays = 0;
                    boxInitialize();
                    // Canvas
                    //ctx.setStrokeColor("rgba(255,255,255,1)");
                    //ctx.strokeRect(0,0,c.width,c.height);

                }
                function update(currentPlayer) {
                    var ballCount = {};
                    ballCount[red] = 0;
                    ballCount[green] = 0;
                    for (i = 1; i <= ROWS; i++) {
                        for (j = 1; j <= COLS; j++) {
                            ballCount[box[i][j].color] += box[i][j].atoms;
                            [].forEach.call(box[i][j].particles, function (particle, index) {
                                particle.y = particle.radius * (Math.cos(particle.angle * (Math.PI / 180))) + i * 100 - 50;
                                particle.x = particle.radius * (Math.sin(particle.angle * (Math.PI / 180))) + j * 100 - 50;
                                particle.angle -= 2;
                                if (particle.angle > 360)
                                    particle.angle = 0;
                            });
                        }
                    }
                    //drawBoard(currentPlayer);
                    //Updates the position of the travelling particles.
                    [].forEach.call(travellingParticles, function (particle, index) {
                        //console.log(particle.axis+" "+particle.curX+" "+particle.curY+" "+particle.toX+" "+particle.toY);
                        ballCount[particle.color] += 1;
                        if (particle.axis == 1) {
                            if (particle.curX == particle.toX * BOX_SIZE - 50) {
                                //document.getElementById("blob").play();
                                box[particle.toX][particle.toY].atoms++;
                                pushAtom(particle.toX, particle.toY);
                                box[particle.toX][particle.toY].color = particle.color;
                                burstIfFull(particle.color, particle.toX, particle.toY);
                                travellingParticles.splice(index, 1);
                            }
                            particle.curX += particle.disp;
                        }
                        else if (particle.axis == 0) {
                            if (particle.curY == particle.toY * BOX_SIZE - 50) {
                                //document.getElementById("blob").play();
                                box[particle.toX][particle.toY].atoms++;
                                pushAtom(particle.toX, particle.toY);
                                box[particle.toX][particle.toY].color = particle.color;
                                burstIfFull(particle.color, particle.toX, particle.toY);
                                travellingParticles.splice(index, 1);

                            }
                            particle.curY += particle.disp;
                        }
                        //drawBoard(currentPlayer);
                    });
                    if (numberOfPlays >= numberOfPlayers) {
                        enableGameOver = true;
                    }
                    if (enableGameOver && condition) {
                        if (ballCount[red] == 0) {

                            var ele = document.getElementById("winner");
                            ele.innerHTML = "Green Wins";
                            document.getElementById("ResultContainer").style.display = "block";
                            condition = false;
                            document.getElementById("ok").addEventListener("click", function () { init(); this.parentNode.parentNode.style.display = "none"; })
                        }
                        else if (ballCount[green] == 0) {
                            var ele = document.getElementById("winner");
                            ele.innerHTML = "Red Wins";
                            document.getElementById("ResultContainer").style.display = "block";
                            condition = false;
                            document.getElementById("ok").addEventListener("click", function () { init(); this.parentNode.parentNode.style.display = "none"; })
                        }
                    }
                    drawBoard(currentPlayer);
                }
                function drawBoard(color) {

                    //ctx.setStrokeColor(color);
                    x = 0, y = 0;
                    for (i = 1; i <= ROWS; i++) {
                        for (j = 1; j <= COLS; j++) {
                            ctx.strokeStyle = color;
                            //ctx.globalCompositeOperation = "source-over";
                            ctx.strokeRect(x, y, BOX_SIZE, BOX_SIZE);
                            ctx.clearRect(x, y, x + BOX_SIZE, y + BOX_SIZE);
                            ctx.fillStyle = box[i][j].color;
                            ctx.strokeStyle = "rgb(51,51,51)";
                            ctx.lineWidth = 2;
                            //          ctx.arc(x+50,y+50,10,0,Math.PI*2); //For Graphics
                            //ctx.globalCompositeOperation = "darker";
                            [].forEach.call(box[i][j].particles, function (particle, index) {
                                ctx.beginPath();
                                ctx.arc(particle.x, particle.y, 15, 0, Math.PI * 2);
                                ctx.closePath();
                                ctx.fill();
                                ctx.stroke();
                            });
                            //ctx.font="20px Arial";
                            //ctx.fillText(box[i][j].atoms,x+50,y+50);
                            x += BOX_SIZE;
                        }
                        x = 0;
                        y += BOX_SIZE;
                    }
                    [].forEach.call(travellingParticles, function (particle, index) {
                        ctx.fillStyle = particle.color;
                        ctx.beginPath();
                        ctx.arc(particle.curY, particle.curX, 15, 0, Math.PI * 2);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                    });
                }

                init();
                //drawBoard(currentPlayer);
                window.setInterval(function () { update(currentPlayer); }, 1000 / 60);
            </script>
        </body>

        </html>